"""
Author(s): Dominik Tran <tran@cesnet.cz>

Copyright: (C) 2022 CESNET, z.s.p.o.
SPDX-License-Identifier: BSD-3-Clause

Module implements TcpReplay class representing tcpreplay tool.
"""

import datetime
import logging
import re
import shutil
import tempfile
from os import path
from pathlib import Path
from typing import Optional

from lbr_testsuite.executable import (
    AsyncTool,
    ExecutableProcessError,
    LocalExecutor,
    Rsync,
    Tool,
)
from src.common.tool_is_installed import assert_tool_is_installed
from src.generator.ft_generator import FtGenerator, FtGeneratorConfig
from src.generator.interface import (
    GeneratorException,
    GeneratorStats,
    MbpsSpeed,
    MultiplierSpeed,
    PcapPlayer,
    PpsSpeed,
    ReplaySpeed,
    TopSpeed,
)
from src.generator.scapy_rewriter import RewriteRules, rewrite_pcap


# pylint: disable=too-many-instance-attributes
class TcpReplay(PcapPlayer):
    """Class provides means to use tcpreplay tool.

    Parameters
    ----------
    executor : Executor, optional
        Executor for command execution.
        Use local execution by default.
    add_vlan : int, optional
        If specified, vlan header with given tag will be added to replayed packets.
    verbose : bool, optional
        If True, logs will collect all debug messages.
    biflow_export : bool, optional
        Used to process ft-generator report. When traffic originates from a profile.
        Flag indicating whether the tested probe exports biflows.
        If the probe exports biflows, the START_TIME resp. END_TIME in the generator
        report contains min(START_TIME,START_TIME_REV) resp. max(END_TIME,END_TIME_REV).
    mtu: int, optional
        Mtu size of interface on which traffic will be replayed.
        Default size is defined by standard MTU with ethernet and VLAN header.
    cache_path : str, optional
        Custom cache path for PCAPs generated by ft-generator on (remote) host.
    """

    # pylint: disable=super-init-not-called
    def __init__(
        self,
        executor=LocalExecutor(),
        add_vlan: Optional[int] = None,
        verbose: bool = False,
        biflow_export: bool = False,
        mtu: int = 1522,
        cache_path: str = None,
    ):
        self._executor = executor
        self._rsync = Rsync(executor)
        self._vlan = add_vlan
        self._interface = None
        self._dst_mac = None
        self._verbose = verbose
        self._mtu = mtu
        self._process = None
        self._pcap_path = ""
        self._ft_generator = FtGenerator(executor, cache_path, biflow_export, verbose)

        self._bin = "tcpreplay"
        assert_tool_is_installed(self._bin, executor)
        self._work_dir = tempfile.mkdtemp()
        self._log_file = Path(self._work_dir, "tcpreplay.log")

    def add_interface(self, ifc_name: str, dst_mac: Optional[str] = None):
        """Add interface on which traffic will be replayed.

        Parameters
        ----------
        ifc_name : str
            String name of interface, e.g. os name or pci address.
        dst_mac : str, optional
            If specified, destination mac address will be edited
            in packets which are replayed on interface.

        Raises
        ------
        RuntimeError
            If more than one interface is added.
        """

        if self._interface:
            raise RuntimeError("Tcpreplay generator supports only one replaying interface.")

        self._interface = ifc_name
        self._dst_mac = dst_mac

    # pylint: disable=arguments-differ
    def start(
        self,
        pcap_path: str,
        speed: ReplaySpeed = MultiplierSpeed(1.0),
        loop_count: int = 1,
    ):
        """Start tcpreplay with given command line options.

        tcpreplay is requires root permissions.

        Parameters
        ----------
        pcap_path : str
            Path to pcap file to replay. Path to PCAP file must be local path.
            Method will synchronize pcap file on remote machine.
        speed : ReplaySpeed, optional
            Argument to modify packets replay speed.
        loop_count : int, optional
            Packets from pcap will be replayed loop_count times.
            Zero or negative value means infinite loop.

        Raises
        ------
        RuntimeError
            If tcpreplay or tcpreplay-edit is missing or
            output interface was not specified.
        GeneratorException
            Tcpreplay process exited unexpectedly with an error.
        """

        if self._process is not None:
            if self._process.is_running():
                self.stop()

        if not self._interface:
            logging.getLogger().error("no output interface was specified")
            raise RuntimeError("no output interface was specified")

        # negative values mean infinite loop
        loop_count = max(loop_count, 0)

        rewrite_rules = None
        if self._dst_mac or self._vlan is not None:
            rewrite_rules = RewriteRules()
            if self._dst_mac:
                rewrite_rules.edit_dst_mac = self._dst_mac
            if self._vlan is not None:
                rewrite_rules.add_vlan = self._vlan

        cmd_options = []
        cmd_options += [self._get_speed_arg(speed)]
        cmd_options += [f"--loop={loop_count}"]
        cmd_options += ["--preload-pcap"]  # always preload pcap file
        cmd_options += [f"--intf1={self._interface}"]
        if self._verbose:
            cmd_options += ["-v"]
        cmd_options += ["--stats=0"]

        Tool(f"ip link set dev {self._interface} up", executor=self._executor, sudo=True).run()
        Tool(f"ip link set dev {self._interface} mtu {self._mtu}", executor=self._executor, sudo=True).run()

        with tempfile.TemporaryDirectory() as temp_dir:
            if rewrite_rules:
                pcap_path = rewrite_pcap(
                    pcap_path,
                    rewrite_rules,
                    path.join(temp_dir, path.basename(pcap_path)),
                )

            self._pcap_path = self._rsync.push_path(pcap_path)
            self._process = AsyncTool(
                f"{self._bin} {' '.join(cmd_options)} {self._pcap_path}",
                sudo=True,
                executor=self._executor,
            )
            self._process.set_outputs(self._log_file)

            try:
                self._process.run()
            except ExecutableProcessError as err:
                raise GeneratorException("tcpreplay startup error") from err

    def start_profile(
        self,
        profile_path: str,
        report_path: str,
        speed: ReplaySpeed = MultiplierSpeed(1.0),
        loop_count: int = 1,
        generator_config: Optional[FtGeneratorConfig] = None,
    ) -> None:
        """Start network traffic replaying from given profile.

        Parameters
        ----------
        profile_path : str
            Path to network profile in CSV form. Path to CSV file must be local path.
            Method will synchronize CSV file when remote is used.
        report_path : str
            Local path to save report CSV (table with generated flows).
            Preprocessed to use with StatisticalModel/FlowReplicator.
        speed : ReplaySpeed, optional
            Argument to modify packets replay speed.
        loop_count : int, optional
            Packets from pcap will be replayed loop_count times.
            Zero or negative value means infinite loop and must be started asynchronous.
        generator_config : FtGeneratorConfig, optional
            Configuration of PCAP generation from profile. Passed to ft-generator.
        """

        pcap, report = self._ft_generator.generate(profile_path, generator_config)

        pcap = self._rsync.pull_path(pcap, self._work_dir)
        report = self._rsync.pull_path(report, self._work_dir)

        self.start(pcap, speed, loop_count)

        shutil.copy(report, report_path)

    def stats(self) -> GeneratorStats:
        """Get stats based on process from ``start`` method.

        This method will block until tcpreplay stops.

        Returns
        -------
        GeneratorStats
            Class containing statistics of sent packets and bytes.
        """

        self._process.wait_or_kill()
        output = Path(self._log_file).read_text(encoding="utf-8")

        pkts = int(re.findall(r"(\d+) packets", output)[-1])
        bts = int(re.findall(r"(\d+) bytes", output)[-1])

        start_time = re.findall(r"Test start: (.*) ...", output)[0].strip()
        start_time = datetime.datetime.fromisoformat(start_time)
        start_time = int(start_time.timestamp() * 1000)

        end_time = re.findall(r"Test complete: (.*)", output)[0].strip()
        end_time = datetime.datetime.fromisoformat(end_time)
        end_time = int(end_time.timestamp() * 1000)

        return GeneratorStats(pkts, bts, start_time, end_time)

    def stop(self, timeout=None):
        """Stop current execution of tcpreplay.

        Parameters
        ----------
        timeout : float, optional
            Kill process if it doesn't finish within
            specified timeout (in seconds).

        Raises
        ------
        GeneratorException
            Tcpreplay process exited unexpectedly with an error.
        """

        if self._process is None:
            return

        try:
            self._process.wait_or_kill(timeout)
        except ExecutableProcessError as err:
            raise GeneratorException("tcpreplay runtime error") from err

    def cleanup(self) -> None:
        """Clean any artifacts created by the connector or the tcpreplay itself."""

        Path(self._log_file).unlink()
        self._rsync.remove_path(self._pcap_path)

    def download_logs(self, directory: str):
        """Download logs from tcpreplay.

        Parameters
        ----------
        directory : str
            Path to a local directory where logs should be stored.
        """

        Path(directory).mkdir(parents=True, exist_ok=True)
        shutil.copy(self._log_file, directory)

    @staticmethod
    def _get_speed_arg(speed: ReplaySpeed) -> str:
        """Prepare tcpreplay argument according to given replay speed modifier.

        Parameters
        ----------
        speed : ReplaySpeed
            Replay speed modifier.

        Returns
        -------
        str
            Tcpreplay argument.

        Raises
        ------
        TypeError
            If speed parameter has unsupported type.
        """

        if isinstance(speed, MultiplierSpeed):
            return f"--multiplier={speed.speed}"
        if isinstance(speed, MbpsSpeed):
            return f"--mbps={speed.speed}"
        if isinstance(speed, PpsSpeed):
            return f"--pps={speed.speed}"
        if isinstance(speed, TopSpeed):
            return "--topspeed"
        raise TypeError("Unsupported speed type.")
