"""
Author(s):  Vojtech Pecen <vojtech.pecen@progress.com>
            Michal Panek <michal.panek@progress.com>

Copyright: (C) 2022 Flowmon Networks a.s.
SPDX-License-Identifier: BSD-3-Clause

Library for managing Flowmon probe"""

import json
import logging
import shutil
import tempfile
import time
from pathlib import Path
from typing import List

from lbr_testsuite.executable import ExecutableProcessError, Rsync, Tool
from lbr_testsuite.executable.rsync import RsyncException
from src.probe.interface import ProbeException, ProbeInterface

FLOWMONEXP_BIN = "/usr/bin/flowmonexp5"
FLOWMONEXP_LOG = Path("/data/components/flowmonexp/log")
QUEUE_SIZE = 22
DPDK_STATS_DIR = Path("/data/components/dpdk-tools/stats/")
DPDK_INFO_FILE = DPDK_STATS_DIR / "ifc_map.csv"

PLUGIN_PARAMS = {
    "as-helper": "/etc/flowmon/flowmon-as.txt",
    "http": "allow-invalid=1",
    "l2": "protocols=MPLS#VLAN#MAC,mac-crc=0,vlan-crc=0,mpls-crc=0",
    "tls": "fields=MAIN#CLIENT#CERT#JA3",
    "vxlan": "port=4789,export_vni=1,decapsulation=1",
}

PROTOCOLS_TO_PLUGINS = {
    "eth": "l2",
    "vlan": "l2",
    "mpls": "l2",
    "tcp": "extended_l3_l4",
    "as": "as-helper",
    "ipv4": "extended_l3_l4",
    "ipv6": "extended_l3_l4",
    "dns": "dns",
    "http": "http",
    "tls": "tls",
    "gre": "gre",
    "vxlan": "vxlan",
}

SPECIAL_FIELDS = {"dns_resp_rr": "OneInArray"}

FIELDS = {
    "common": [
        "bytes",
        "packets",
        "protocol",
        "tcp_flags",
        "src_port",
        "dst_port",
        "src_ip",
        "dst_ip",
        "ip_version",
        "icmp_type_code",
    ],
    "l2": [
        "src_mac",
        "dst_mac",
        "vlan_id",
        "vlan_id_inner",
        "mpls_label_1",
        "mpls_label_2",
    ],
    "vxlan": [
        "vxlan_id",
    ],
    "as-helper": [
        "src_asn",
        "dst_asn",
    ],
    "extended_l3_l4": [
        "tcp_syn_size",
        "tos",
        "ttl",
    ],
    "dns": [
        "dns_id",
        "dns_flags",
        "dns_req_query_type",
        "dns_req_query_class",
        "dns_req_query_name",
        "dns_resp_rr",
        "dns_resp_rr.name",
        "dns_resp_rr.type",
        "dns_resp_rr.class",
        "dns_resp_rr.ttl",
        "dns_resp_rr.flowmon_data",
    ],
    "http": [
        "http_host",
        "http_url",
        "http_method_id",
        "http_status_code",
        "http_agent",
        "http_content_type",
        "http_referer",
    ],
    "tls": [
        "tls_server_version",
        "tls_cipher_suite",
        "tls_alpn",
        "tls_sni",
        "tls_client_version",
        "tls_issuer_cn",
        "tls_subject_cn",
        "tls_validity_not_before",
        "tls_validity_not_after",
        "tls_public_key_alg",
        "tls_ja3",
    ],
}


# pylint: disable=too-many-instance-attributes
class FlowmonProbe(ProbeInterface):
    """Flowmon Probe exporter. It's able to start, stop and terminate flow exporting process
    on a single monitoring interface."""

    # pylint: disable=too-many-locals
    def __init__(
        self,
        executor,
        target,
        protocols,
        interfaces,
        verbose=False,
        mtu=1522,
        active_timeout=300,
        inactive_timeout=30,
    ):
        """Create JSON configuration file for a single exporting process
        based on the provided configuration and actual host server attributes.
        The configuration file is saved on the host server.

        executor : lbr_testsuite.executable.Executor
            Initialized executor object with the deployed probe.

        target : src.probe.ProbeTarget
            Export target where all flow data generated by the probe should be sent.

        protocols : list
            List of networking protocols which the probe should parse and export.

        interfaces : list(InterfaceCfg)
            Network interfaces where the exporting process should be initiated.

        verbose : bool, optional
            If True, set verbosity of probe logs to DEBUG and also output flows
            to JSON, otherwise set verbosity to WARN. Default is False.

        mtu : int
            The maximum transmission unit to be set at the probe input.

        active_timeout : int, optional
            Maximum duration of an ongoing flow before the probe exports it (in seconds).

        inactive_timeout : int, optional
            Maximum duration for which a flow is kept in the probe if no new data updates it (in seconds).
        """

        if len(interfaces) != 1:
            raise ProbeException("Exporting process should be initiated on exactly one input interface.")
        interface = interfaces[0].name

        self._executor = executor

        dpdk_is_active = Tool(
            "systemctl -q is-active dpdk-controller.service", executor=self._executor, failure_verbosity="silent"
        )
        dpdk_is_active.run()
        if dpdk_is_active.returncode() == 0:
            input_plugin = "dpdk"
        else:
            input_plugin = "rawnetcap"

        self._plugins = list({PROTOCOLS_TO_PLUGINS[p] for p in protocols if p in PROTOCOLS_TO_PLUGINS})

        self._interface = interface
        self._pidfile = f"/tmp/tmp_probe_{interface}.pidfile"
        self._settings = {}
        self._verbose = verbose
        self._mtu = mtu
        self._remote_dir = Path(Rsync(self._executor).get_data_directory())
        attributes = self._get_appliance_attributes(input_plugin)
        self._set_config(
            QUEUE_SIZE,
            active_timeout,
            inactive_timeout,
            attributes,
        )
        self._set_input(
            input_plugin,
            attributes,
        )
        self._set_plugins()
        self._set_filters(attributes)
        self._set_output(target)
        self._pid = None
        startup_conf = f"probe_{interface}.json"
        self._probe_json_conf = self._remote_dir / startup_conf

        local_temp_dir = tempfile.mkdtemp()
        local_conf_file = Path(local_temp_dir) / startup_conf
        try:
            with open(local_conf_file, "w", encoding="utf=8") as file:
                json.dump(self._settings, file, indent=4, separators=(",", ": "))
        except IOError as err:
            logging.getLogger().error("Unable to save probe configuration locally %s", err)
            raise ProbeException(f"Unable to save probe configuration locally : {err}") from err
        except TypeError as err:
            logging.getLogger().error("Unable to create json configuration file %s", err)
            raise ProbeException(f"Unable to create json configuration file : {err}") from err

        Rsync(executor).push_path(str(local_conf_file))
        shutil.rmtree(local_temp_dir)

    def _get_appliance_attributes(self, input_plugin):
        """Returns dict of appliance attributes"""

        attributes = {}
        if input_plugin == "rawnetcap":
            cmd = f"cat /sys/class/net/{self._interface}/device/numa_node"
            try:
                attributes["numa_node"] = int(Tool(cmd, executor=self._executor).run()[0])
            except ExecutableProcessError as err:
                logging.getLogger().error("Interface %s is not present on target host, err : %d", self._interface, err)
                raise ProbeException(f"{self._interface} is not present on target host.") from err
            if attributes["numa_node"] == -1:
                attributes["numa_node"] = 0
            attributes["ifindex"] = int(
                Tool(f"cat /sys/class/net/{self._interface}/ifindex", executor=self._executor).run()[0]
            )
        elif input_plugin == "dpdk":
            attributes = self._read_dpdk_info_file()
        return attributes

    def _read_dpdk_info_file(self):
        """Read configuration details for the dpdk"""

        ifc_map = (
            Tool(f"cat {DPDK_INFO_FILE} | grep {self._interface}", executor=self._executor, failure_verbosity="silent")
            .run()[0]
            .split()
        )
        if len(ifc_map) == 12:
            dpdk_info = {
                "device": ifc_map[0],
                "driver_name": ifc_map[4],
                "numa_node": int(ifc_map[6]),
                "pmd": ifc_map[8],
                "cores": ifc_map[9],
                "ifindex": int(ifc_map[11]),
            }
            return dpdk_info
        logging.getLogger().error("Unable to find interface %s in %d", self._interface, DPDK_INFO_FILE)
        raise ProbeException(f"Unable to find interface {self._interface} in {DPDK_INFO_FILE}.")

    def _set_config(self, queue_size, active_timeout, inactive_timeout, attributes):
        """Setup basic parameters for probe configuration"""

        self._settings["OPTIONS"] = "DBUS_MODE=OFF,MPLS_MODE=0,SPLIT_BIFLOWS=1"
        self._settings["PLUGIN-DIR"] = "/usr/lib64/flowmonexp5"
        self._settings["DAEMON"] = True
        self._settings["QUEUE-SIZE"] = int(queue_size)
        self._settings["ACTIVE-TIMEOUT"] = int(active_timeout)
        self._settings["INACTIVE-TIMEOUT"] = int(inactive_timeout)
        self._settings["NUMA-NODE"] = attributes["numa_node"]
        self._settings["USER"] = "flowmon"
        if self._verbose:
            self._settings["VERBOSE"] = "DEBUG"
        else:
            self._settings["VERBOSE"] = "INFO"
        self._settings["PID-FILE"] = self._pidfile

    def _set_input(self, input_plugin, attributes):
        """Setup input part of flowmon probe configuration."""

        if input_plugin == "rawnetcap":
            input_parameters = f"device={self._interface},sampling=0,cache-size=32768,mtu={self._mtu}"
            self._settings["INPUT"] = {"NAME": input_plugin, "PARAMS": input_parameters}
        elif input_plugin == "dpdk":
            input_parameters = (
                f'name={attributes["driver_name"]},device={attributes["device"]},'
                + f'cores={attributes["cores"]},pmd={attributes["pmd"]},'
                + f"stats=/data/components/dpdk-tools/stats/{self._interface},sampling=0,mtu={self._mtu}"
            )
            self._settings["INPUT"] = {"NAME": input_plugin, "PARAMS": input_parameters}

    def _set_plugins(self):
        """Responsible for compiling part of the probe
        configuration consisting of used export plugins"""

        self._settings["PROCESS"] = [{"NAME": item, "PARAMS": PLUGIN_PARAMS.get(item, "")} for item in self._plugins]

    def _set_filters(self, attributes):
        """Compiles probe configuration regarding used filters."""

        ifindex = attributes["ifindex"]
        self._settings["FILTERS"] = [{"NAME": "interface-id", "PARAMS": f"input-id={ifindex},output-id=0"}]

    def _set_output(self, target):
        """Setup the output part of the flowmon probe configuration."""

        self._settings["OUTPUTS"] = [
            {
                "NAME": "ipfix-ng",
                "PARAMS": f"host={target.host},port={target.port},protocol={target.protocol},"
                f"source-id=1,template-refresh-packets=4096,template-refresh-time=600",
                "FILTERS": [],
            }
        ]

        if self._verbose:
            self._remote_json_output = self._remote_dir / "probe_output.json"
            self._settings["OUTPUTS"].append(
                {
                    "NAME": "json",
                    "PARAMS": f"pretty=1,savefile={self._remote_json_output}",
                    "FILTERS": [],
                }
            )

    def _prepare_logs(self) -> List[Path]:
        """Prepare list of log files to download.

        Returns
        -------
        List
            Paths to log files.
        """
        log_files = [
            self._probe_json_conf,  # already present in the working directory
            "flowmonexp.log",
            "flowmonexp_init.log",
        ]

        Tool(f"cp {FLOWMONEXP_LOG / 'flowmonexp.log'} {self._remote_dir}", executor=self._executor).run()

        # flowmonexp_init.log is not readable by flowmon, need to use this workaround
        # The sudo parameter of the Tool class cannot be used because of selective permission
        # of flowmon user on flowmon probe. Command is transformed to form 'sudo -E sh -c cmd'.
        # User cannot run 'sh' under sudo.
        Tool(
            f"sudo tail -n 10000 {FLOWMONEXP_LOG / 'flowmonexp_init.log'} > {self._remote_dir / 'flowmonexp_init.log'}",
            executor=self._executor,
        ).run()

        if self._verbose:
            log_files.extend([self._remote_json_output, "flowmonexp_debug.log"])
            # json output is already present in the working directory
            Tool(f"cp {FLOWMONEXP_LOG / 'flowmonexp_debug.log'} {self._remote_dir}", executor=self._executor).run()

        # get interface statistics in the INPUT plugin is DPDK
        if self._settings["INPUT"]["NAME"] == "dpdk":
            stats_file = f"{self._interface}_stats.json"
            log_files.append(stats_file)
            Tool(
                f"cp {DPDK_STATS_DIR / self._interface} {self._remote_dir / stats_file}", executor=self._executor
            ).run()

        return log_files

    def supported_fields(self):
        """Returns list of IPFIX fields the probe may export in its current configuration.

        Returns
        -------
        List
            Fields which may present in the flows.
        """

        fields_2d = [FIELDS.get(p, []) for p in self._plugins + ["common"]]
        return [p for sub in fields_2d for p in sub]

    def get_special_fields(self):
        """Get list of IPFIX fields the probe may export in its current configuration
        and need special evaluation.

        Returns
        -------
        Dict
            of special fields with way to evaluate them
        """

        fields = self.supported_fields()
        return {name: value for name, value in SPECIAL_FIELDS.items() if name in fields}

    def start(self):
        """Start flowmonexp5 process"""

        # remove logs from previous run
        Tool(f"rm -f {FLOWMONEXP_LOG}/*.log").run()
        logging.getLogger().info("Starting exporter on %s", self._interface)
        cmd = f"{FLOWMONEXP_BIN} {self._probe_json_conf}"
        check_running_cmd = f"ps aux | grep -Ei '[f]lowmonexp5.*{self._interface}'"
        running_processes = Tool(check_running_cmd, executor=self._executor, failure_verbosity="silent").run()[0]
        if len(running_processes) > 0:
            running_pid = int(running_processes.split()[1])
            self._stop_process(running_pid)
            time.sleep(2)
        try:
            # The sudo parameter of the Tool class cannot be used because of selective permission
            # of flowmon user on flowmon probe. Command is transformed to form 'sudo -E sh -c cmd'.
            # User cannot run 'sh' under sudo.
            Tool(f"sudo {cmd}", executor=self._executor).run()
            time.sleep(3)
            self._pid = int(Tool(f"cat {self._pidfile}", executor=self._executor).run()[0])
        except (ExecutableProcessError, ValueError) as err:
            logging.getLogger().error("Unable to start probe on %s.", self._interface)
            raise ProbeException(f"Unable to start probe on {self._interface}.") from err

    def stop(self):
        """Stop the flowmonexp5 process"""

        # if process not running, method has no effect
        if not self._pid:
            return

        logging.getLogger().info("Stopping exporter on %s", self._interface)
        self._stop_process(self._pid)
        self._pid = None

    def _stop_process(self, pid):
        """Stop exporter process"""

        Tool(f"kill -2 {pid}", executor=self._executor, failure_verbosity="silent").run()
        ps_cmd = Tool(f"ps -p {pid}", executor=self._executor, failure_verbosity="silent")
        for _ in range(5):
            ps_cmd.run()
            if ps_cmd.returncode() > 0:
                return
            time.sleep(1)
        logging.getLogger().warning("Unable to stop exporter process with SIGINT, using SIGKILL.")
        Tool(f"kill -9 {pid}", executable=self._executor, failure_verbosity="silent")

    def cleanup(self):
        """Clean any artifacts which were created by the connector or the active probe itself."""

        logging.getLogger().info("Cleaning up remote temporary directory %s", self._remote_dir)
        try:
            Rsync(self._executor).wipe_data_directory()
        except ExecutableProcessError as err:
            logging.getLogger().error("Unable to remove files in %s", self._remote_dir)
            raise ProbeException(f"Unable to remove files in {self._remote_dir}.") from err

    def download_logs(self, directory: str):
        """Download logs from flowmon probe.

        Parameters
        ----------
        directory : str
            Path to a local directory where logs should be stored.
        """
        storage = Rsync(self._executor)
        for log_file in self._prepare_logs():
            try:
                storage.pull_path(str(log_file), directory)
            except RsyncException as err:
                logging.getLogger().warning("%s", err)

    def get_timeouts(self) -> tuple[int, int]:
        """Get active and inactive timeouts of the probe (in seconds).

        Returns
        -------
        tuple
            active_timeout, inactive_timeout
        """

        return self._settings["ACTIVE-TIMEOUT"], self._settings["INACTIVE-TIMEOUT"]
