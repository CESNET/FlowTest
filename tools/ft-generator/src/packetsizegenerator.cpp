/**
 * @file
 * @author Michal Sedlak <sedlakm@cesnet.cz>
 * @brief Packet size value generator
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "packetsizegenerator.h"
#include "randomgenerator.h"

#include <algorithm>
#include <cassert>

namespace generator {

// Maximum number of attempts when generating
static constexpr int MAX_ATTEMPTS = 2000;

// How much can the generated byte count differ from the desired one
static constexpr double MAX_DIFF_RATIO = 0.01;

// Minimal allowed difference, as we might never be able to reach the exact amount with smaller byte
// counts
static constexpr double MIN_DIFF = 50;

// The maximum distance to look when finding a suitable value when choosing an exact value
static constexpr int GET_EXACT_MAX_DISTANCE = 1000;

// The maximum number of generated sizes in which to keep track of the best generated values every
// step. For larger counts, this could be a very expensive operation.
static constexpr int SAVE_VALUES_EVERY_STEP_THRESHOLD = 2000;

// If the generated sum differs by the desired sum by this much percent, fallback to uniform
// distribution.
static constexpr double DIFF_RATIO_FALLBACK_TO_UNIFORM = 0.2;

PacketSizeGenerator::PacketSizeGenerator(
	uint64_t count,
	uint64_t desiredSum,
	const std::vector<IntervalInfo>& intervals)
	: _count(count)
	, _desiredSum(desiredSum)
	, _intervals(intervals)
{
	_saveBestValuesEveryStep = (_count < SAVE_VALUES_EVERY_STEP_THRESHOLD);

	PostIntervalUpdate();
	Generate();
}

void PacketSizeGenerator::Generate()
{
	uint64_t valuesSum = 0;
	_values.resize(_count);

	if (_desiredSum == 0) {
		return;
	}

	if (_count == 1) {
		_values[0] = _desiredSum;
		return;
	}

	for (auto& value : _values) {
		value = GenerateRandomValue();
		valuesSum += value;
	}

	double maxDiff = std::max<uint64_t>(MAX_DIFF_RATIO * _desiredSum, MIN_DIFF);
	uint64_t targetMin = maxDiff < _desiredSum ? _desiredSum - maxDiff : 0;
	uint64_t targetMax = _desiredSum + maxDiff;

	_logger->trace("VALUES sum={} desired={}", valuesSum, _desiredSum);
	for (auto value : _values) {
		_logger->trace(value);
	}

	int numAttempts = MAX_ATTEMPTS;
	uint64_t bestDiff = valuesSum > _desiredSum ? valuesSum - _desiredSum : _desiredSum - valuesSum;
	std::vector<uint64_t> bestValues = _values;
	while ((valuesSum < targetMin || valuesSum > targetMax) && numAttempts > 0) {
		numAttempts--;

		uint64_t avgValue = valuesSum / _count;
		std::vector<IntervalInfo> origIntervals = _intervals;
		if (valuesSum < targetMin) {
			for (auto& inter : _intervals) {
				uint64_t interAvg = inter._from / 2 + inter._to / 2;
				if (interAvg < avgValue) {
					inter._probability = 0.0;
				}
			}
		} else {
			for (auto& inter : _intervals) {
				uint64_t interAvg = inter._from / 2 + inter._to / 2;
				if (interAvg < avgValue) {
					inter._probability = 0.0;
				}
			}
		}
		PostIntervalUpdate();

		for (auto& value : _values) {
			uint64_t newValue = GenerateRandomValue();
			valuesSum = valuesSum - value + newValue;
			value = newValue;

			if (valuesSum >= targetMin && valuesSum <= targetMax) {
				break;
			}
			if (_saveBestValuesEveryStep) {
				uint64_t diff
					= valuesSum > _desiredSum ? valuesSum - _desiredSum : _desiredSum - valuesSum;
				if (diff < bestDiff) {
					bestValues = _values;
					bestDiff = diff;
				}
			}
		}

		_logger->trace("VALUES sum={} desired={}", valuesSum, _desiredSum);
		for (auto value : _values) {
			_logger->trace(value);
		}

		_intervals = origIntervals;
		PostIntervalUpdate();

		uint64_t diff = valuesSum > _desiredSum ? valuesSum - _desiredSum : _desiredSum - valuesSum;
		if (diff < bestDiff) {
			bestValues = _values;
			bestDiff = diff;
		}
	}

	double finalDiffRatio = double(bestDiff) / double(_desiredSum);
	_logger->trace("Final diff: {}, ratio: {}, desired: {}", bestDiff, finalDiffRatio, _desiredSum);

	if (finalDiffRatio > DIFF_RATIO_FALLBACK_TO_UNIFORM) {
		GenerateUniformly();
		_logger->info(
			"Generated values difference too large {}, fallback to uniform distribution",
			finalDiffRatio);
	} else {
		_values = std::move(bestValues);
		std::shuffle(_values.begin(), _values.end(), std::default_random_engine());
	}
}

uint64_t PacketSizeGenerator::GetValue()
{
	uint64_t value = _values.back();
	_values.pop_back();
	return value;
}

uint64_t PacketSizeGenerator::GetValueExact(uint64_t value)
{
	size_t start;
	size_t end;
	if (_values.size() <= GET_EXACT_MAX_DISTANCE) {
		start = 0;
		end = _values.size();
	} else {
		start
			= RandomGenerator::GetInstance().RandomUInt(0, _values.size() - GET_EXACT_MAX_DISTANCE);
		end = start + GET_EXACT_MAX_DISTANCE;
	}

	size_t closest = 0;
	uint64_t closestDiff = value;
	for (size_t i = start; i < end; i++) {
		uint64_t diff = _values[i] > value ? _values[i] - value : value - _values[i];
		if (diff < closestDiff) {
			closest = i;
			closestDiff = diff;
		}
	}

	std::swap(_values[closest], _values[_values.size() - 1]);

	uint64_t chosenValue = _values.back();
	_values.pop_back();
	return chosenValue;
}

void PacketSizeGenerator::PostIntervalUpdate()
{
	_intervalProbSum = std::accumulate(
		_intervals.begin(),
		_intervals.end(),
		0.0,
		[](double sum, const auto& inter) { return sum += inter._probability; });
}

uint64_t PacketSizeGenerator::GenerateRandomValue()
{
	double probSum = 0.0f;
	double genVal = RandomGenerator::GetInstance().RandomDouble(0.0, _intervalProbSum);
	uint64_t value = 0;
	for (const auto& inter : _intervals) {
		probSum += inter._probability;
		if (genVal <= probSum) {
			value = RandomGenerator::GetInstance().RandomUInt(inter._from, inter._to);
			break;
		}
	}
	return value;
}

void PacketSizeGenerator::GenerateUniformly()
{
	std::fill(_values.begin(), _values.end(), _desiredSum / _values.size());
}

} // namespace generator
